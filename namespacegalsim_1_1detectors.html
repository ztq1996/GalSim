<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.detectors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1detectors.html">detectors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim.detectors Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a373c8fc7fad6f2633ae1407ee631912b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1detectors.html#a373c8fc7fad6f2633ae1407ee631912b">applyNonlinearity</a></td></tr>
<tr class="memdesc:a373c8fc7fad6f2633ae1407ee631912b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given non-linearity function (<code>NLfunc</code>) on the Image instance directly.  <a href="#a373c8fc7fad6f2633ae1407ee631912b">More...</a><br/></td></tr>
<tr class="separator:a373c8fc7fad6f2633ae1407ee631912b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b8d9f206b33705f9e5260c49b1e2bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1detectors.html#a79b8d9f206b33705f9e5260c49b1e2bb">addReciprocityFailure</a></td></tr>
<tr class="memdesc:a79b8d9f206b33705f9e5260c49b1e2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accounts for the reciprocity failure and includes it in the original Image directly.  <a href="#a79b8d9f206b33705f9e5260c49b1e2bb">More...</a><br/></td></tr>
<tr class="separator:a79b8d9f206b33705f9e5260c49b1e2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb90af8bf9f48b7713defd5694f049"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1detectors.html#aeecb90af8bf9f48b7713defd5694f049">applyIPC</a></td></tr>
<tr class="memdesc:aeecb90af8bf9f48b7713defd5694f049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the effect of interpixel capacitance to the Image instance.  <a href="#aeecb90af8bf9f48b7713defd5694f049">More...</a><br/></td></tr>
<tr class="separator:aeecb90af8bf9f48b7713defd5694f049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e4fee9bf7799384cecd686b7dd0055"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1detectors.html#aa6e4fee9bf7799384cecd686b7dd0055">quantize</a></td></tr>
<tr class="memdesc:aa6e4fee9bf7799384cecd686b7dd0055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the pixel values in an image to integer values, while preserving the type of the data.  <a href="#aa6e4fee9bf7799384cecd686b7dd0055">More...</a><br/></td></tr>
<tr class="separator:aa6e4fee9bf7799384cecd686b7dd0055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a79b8d9f206b33705f9e5260c49b1e2bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.detectors.addReciprocityFailure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exp_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accounts for the reciprocity failure and includes it in the original Image directly. </p>
<p>Reciprocity, in the context of photography, is the inverse relationship between the incident flux (I) of a source object and the exposure time (t) required to produce a given response (p) in the detector, i.e., p = I*t. At very low (also at high) levels of incident flux, deviation from this relation is observed, leading to reduced sensitivity at low flux levels. The pixel response to a high flux is larger than its response to a low flux. This flux-dependent non- linearity is known as 'Reciprocity Failure' and is known to happen in photographic films since</p>
<ol type="1">
<li>Interested users can refer to <a href="http://en.wikipedia.org/wiki/Reciprocity_(photography)">http://en.wikipedia.org/wiki/Reciprocity_(photography)</a></li>
</ol>
<p>CCDs are not known to suffer from this effect. HgCdTe detectors that are used for near infrared astrometry, although to an extent much lesser than the photographic films, are found to exhibit reciprocity failure at low flux levels. The exact mechanism of this effect is unknown and hence we lack a good theoretical model. Many models that fit the empirical data exist and a common relation is </p>
<pre class="fragment">    pR/p = (1 + alpha*log10(p/t) - alpha*log10(p'/t'))
</pre><p>where t is the exposure time (in units of seconds), p is the pixel response (in units of electrons) and pR is the response if the reciprocity relation fails to hold. p'/t' is count rate (in electrons/second) corresponding to the photon flux (base flux) at which the detector is calibrated to have its nominal gain. alpha is the parameter in the model, measured in units of per decade and varies with detectors and the operating temperature. The functional form for the reciprocity failure is motivated empirically from the tests carried out on H2RG detectors. See for reference Fig. 1 and Fig. 2 of <a href="http://arxiv.org/abs/1106.1090">http://arxiv.org/abs/1106.1090</a>. Since pR/p remains close to unity over a wide range of flux, we convert this relation to a power law by approximating (pR/p)-1 ~ log(pR/p). This gives a relation that is better behaved than the logarithmic relation at low flux levels. </p>
<pre class="fragment">    pR/p = ((p/t)/(p'/t'))^(alpha/log(10)).
</pre><p>Because of how this function is defined, the input image must have non-negative pixel values for the resulting image to be well-defined. Negative pixel values result in 'nan's. The image should be in units of electrons, or if it is in ADU, then the value passed to exp_time should be the exposure time divided by the nominal gain. The image should include both the signal from the astronomical objects as well as the background level. The addition of nonlinearity should occur after including the effect of reciprocity failure.</p>
<h2>Calling </h2>
<pre class="fragment">&gt;&gt;&gt;  img.addReciprocityFailure(exp_time, alpha, base_flux)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp_time</td><td>The exposure time (t) in seconds, which goes into the expression for reciprocity failure given in the docstring. </td></tr>
    <tr><td class="paramname">alpha</td><td>The alpha parameter in the expression for reciprocity failure, in units of 'per decade'. </td></tr>
    <tr><td class="paramname">base_flux</td><td>The flux (p'/t') at which the gain is calibrated to have its nominal value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeecb90af8bf9f48b7713defd5694f049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.detectors.applyIPC </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>IPC_kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_treatment</em> = <code>'extend'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kernel_nonnegativity</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kernel_normalization</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the effect of interpixel capacitance to the Image instance. </p>
<p>In NIR detectors, the quantity that is sensed is not the charge as in CCDs, but a voltage that relates to the charge present within each pixel. The voltage read at a given pixel location is influenced by the charges present in the neighboring pixel locations due to capacitive coupling of sense nodes.</p>
<p>This interpixel capacitance is approximated as a linear effect that can be described by a 3x3 kernel that is convolved with the image. The kernel must be an Image instance and could be intrinsically anisotropic. A sensible kernel must have non-negative entries and must be normalized such that the sum of the elements is 1, in order to conserve the total charge. The (1,1) element of the kernel is the contribution to the voltage read at a pixel from the electrons in the pixel to its bottom-left, the (1,2) element of the kernel is the contribution from the charges to its left and so on.</p>
<p>The argument 'edge_treatment' specifies how the edges of the image should be treated, which could be in one of the three ways:</p>
<ol type="1">
<li>'extend': The kernel is convolved with the zero-padded image, leading to a larger intermediate image. The central portion of this image is returned. [default]</li>
<li>'crop': The kernel is convolved with the image, with the kernel inside the image completely. Pixels at the edges, where the center of the kernel could not be placed, are set to the value specified by 'fill_value'. If 'fill_value' is not specified or set to 'None', then the pixel values in the original image are retained. The user can make the edges invalid by setting fill_value to numpy.nan.</li>
<li>'wrap': The kernel is convolved with the image, assuming periodic boundary conditions.</li>
</ol>
<p>The size of the image array remains unchanged in all three cases.</p>
<h2>Calling </h2>
<pre class="fragment">&gt;&gt;&gt; img.applyIPC(IPC_kernel=ipc_kernel, edge_treatment='extend', fill_value=0,
    kernel_nonnegativity=True, kernel_normalization=True)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IPC_kernel</td><td>A 3x3 Image instance that is convolved with the Image instance </td></tr>
    <tr><td class="paramname">edge_treatment</td><td>Specifies the method of handling edges and should be one of 'crop', 'extend' or 'wrap'. See above for details. [default: 'extend'] </td></tr>
    <tr><td class="paramname">fill_value</td><td>Specifies the value (including nan) to fill the edges with when edge_treatment is 'crop'. If unspecified or set to 'None', the original pixel values are retained at the edges. If edge_treatment is not 'crop', then this is ignored. </td></tr>
    <tr><td class="paramname">kernel_nonnegativity</td><td>Specify whether the kernel should have only non-negative entries. [default: True] </td></tr>
    <tr><td class="paramname">kernel_normalization</td><td>Specify whether to check and enforce correct normalization for the kernel. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a373c8fc7fad6f2633ae1407ee631912b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.detectors.applyNonlinearity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NLfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given non-linearity function (<code>NLfunc</code>) on the Image instance directly. </p>
<p>This routine can transform the image in a non-linear manner specified by the user. However, the typical kind of non-linearity one sees in astronomical images is voltage non-linearity, also sometimes known as 'classical non-linearity', refers to the non-linearity in charge-to-voltage conversion process. This arises as charge gets integrated at the junction capacitance of the pixel node. Voltage non-linearity decreases signals at higher signal levels, causing the attenuation of brighter pixels. The image should include both the signal from the astronomical objects as well as the background level. Other detectors effects such as dark current and persistence (not currently included in GalSim) would also occur before the inclusion of nonlinearity.</p>
<p>The argument <code>NLfunc</code> is a callable function (for example a lambda function, a galsim.LookupTable, or a user-defined function), possibly with arguments that need to be given as subsequent arguments to the <code>applyNonlinearity</code> function (after the <code>NLfunc</code> argument). <code>NLfunc</code> should be able to take a 2d NumPy array as input, and return a NumPy array of the same shape. It should be defined such that it outputs the final image with nonlinearity included (i.e., in the limit that there is no nonlinearity, the function should return the original image, NOT zero). The image should be in units of electrons when this routine is being used to generate classical non-linearity. When used for other purposes, the units can be in electrons or in ADU, as found appropriate by the user.</p>
<h2>Calling with no parameter: </h2>
<pre class="fragment">&gt;&gt;&gt; f = lambda x: x + (1.e-7)*(x**2)
&gt;&gt;&gt; img.applyNonlinearity(f)
</pre><h2>Calling with 1 or more parameters: </h2>
<pre class="fragment">&gt;&gt;&gt; f = lambda x, beta1, beta2: x - beta1*x*x + beta2*x*x*x
&gt;&gt;&gt; img.applyNonlinearity(f, 1.e-7, 1.e-10)
</pre><p>On calling the method, the Image instance <code>img</code> is transformed by the user-defined function <code>f</code> with <code>beta1</code> = 1.e-7 and <code>beta2</code> = 1.e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NLfunc</td><td>The function that maps the input image pixel values to the output image pixel values. </td></tr>
    <tr><td class="paramname">*args</td><td>Any subsequent arguments are passed along to the NLfunc function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6e4fee9bf7799384cecd686b7dd0055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.detectors.quantize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the pixel values in an image to integer values, while preserving the type of the data. </p>
<p>At certain stages in the astronomical image generation process, detectors effectively round to the nearest integer. The exact stage at which this happens depends on the type of device (CCD vs. NIR detector). For example, for H2RG detectors, quantization happens in two stages: first, when detecting a certain number of photons, corresponding to the sum of background and signal multiplied by the QE and including reciprocity failure. After this, a number of other processes occur (e.g., nonlinearity, IPC, read noise) that could result in non-integer pixel values, only rounding to an integer at the stage of analog-to-digital conversion.</p>
<p>Because we cannot guarantee that quantization will always be the last step in the process, the <a class="el" href="namespacegalsim_1_1detectors.html#aa6e4fee9bf7799384cecd686b7dd0055" title="Rounds the pixel values in an image to integer values, while preserving the type of the data...">quantize()</a> routine does not actually modify the type of the image to 'int'. However, users can easily do so by doing </p>
<pre class="fragment">image.quantize()
int_image = galsim.Image(image, dtype=int)</pre> 
</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
