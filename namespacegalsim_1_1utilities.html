<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim.utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_attribute_dict.html">AttributeDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary class that allows for easy initialization and refs to key values via attributes.  <a href="classgalsim_1_1utilities_1_1_attribute_dict.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_l_r_u___cache.html">LRU_Cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified Least Recently Used Cache.  <a href="classgalsim_1_1utilities_1_1_l_r_u___cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_simple_generator.html">SimpleGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that is constructed with an arbitrary object.  <a href="classgalsim_1_1utilities_1_1_simple_generator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13e9d483f84e5d442b47384d26f5f65b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a13e9d483f84e5d442b47384d26f5f65b">roll2d</a></td></tr>
<tr class="memdesc:a13e9d483f84e5d442b47384d26f5f65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently.  <a href="#a13e9d483f84e5d442b47384d26f5f65b">More...</a><br/></td></tr>
<tr class="separator:a13e9d483f84e5d442b47384d26f5f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ae3d1586e7c70ecfd9582b71f6f5147ab">kxky</a></td></tr>
<tr class="memdesc:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape.  <a href="#ae3d1586e7c70ecfd9582b71f6f5147ab">More...</a><br/></td></tr>
<tr class="separator:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5623a48fc511636b486d42816ba940"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a9e5623a48fc511636b486d42816ba940">g1g2_to_e1e2</a></td></tr>
<tr class="memdesc:a9e5623a48fc511636b486d42816ba940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>.  <a href="#a9e5623a48fc511636b486d42816ba940">More...</a><br/></td></tr>
<tr class="separator:a9e5623a48fc511636b486d42816ba940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e66b2539898963681cd1bf1fba0214"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af0e66b2539898963681cd1bf1fba0214">rotate_xy</a></td></tr>
<tr class="memdesc:af0e66b2539898963681cd1bf1fba0214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system.  <a href="#af0e66b2539898963681cd1bf1fba0214">More...</a><br/></td></tr>
<tr class="separator:af0e66b2539898963681cd1bf1fba0214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af424a90c9e1c9f64eaaf4f52bcb1aceb">parse_pos_args</a></td></tr>
<tr class="memdesc:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the args and kwargs of a function call to be some kind of position.  <a href="#af424a90c9e1c9f64eaaf4f52bcb1aceb">More...</a><br/></td></tr>
<tr class="separator:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd8593ea30d16263c2f03e1147b5b27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#abbd8593ea30d16263c2f03e1147b5b27">rand_arr</a></td></tr>
<tr class="memdesc:abbd8593ea30d16263c2f03e1147b5b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 2d array of random deviates (of any sort).  <a href="#abbd8593ea30d16263c2f03e1147b5b27">More...</a><br/></td></tr>
<tr class="separator:abbd8593ea30d16263c2f03e1147b5b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0f1e1e39e1ac7f446f278746918992"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#adf0f1e1e39e1ac7f446f278746918992">convert_interpolant</a></td></tr>
<tr class="memdesc:adf0f1e1e39e1ac7f446f278746918992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string.  <a href="#adf0f1e1e39e1ac7f446f278746918992">More...</a><br/></td></tr>
<tr class="separator:adf0f1e1e39e1ac7f446f278746918992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726162f079025bf5e5a622702d001ad7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a726162f079025bf5e5a622702d001ad7">thin_tabulated_values</a></td></tr>
<tr class="memdesc:a726162f079025bf5e5a622702d001ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a726162f079025bf5e5a622702d001ad7">More...</a><br/></td></tr>
<tr class="separator:a726162f079025bf5e5a622702d001ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d0acc084bdcb8cb85892463661233"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#aaf4d0acc084bdcb8cb85892463661233">interleaveImages</a></td></tr>
<tr class="memdesc:aaf4d0acc084bdcb8cb85892463661233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the pixel values from two or more images and into a single larger image.  <a href="#aaf4d0acc084bdcb8cb85892463661233">More...</a><br/></td></tr>
<tr class="separator:aaf4d0acc084bdcb8cb85892463661233"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adf0f1e1e39e1ac7f446f278746918992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.convert_interpolant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> if it is given as a string. </p>

</div>
</div>
<a class="anchor" id="a9e5623a48fc511636b486d42816ba940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.g1g2_to_e1e2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for going from <code>(g1, g2)</code> -&gt; <code>(e1, e2)</code>. </p>
<p>Here <code>g1</code> and <code>g2</code> are reduced shears, and <code>e1</code> and <code>e2</code> are distortions - see shear.py for definitions of reduced shear and distortion in terms of axis ratios or other ways of specifying ellipses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First reduced shear component </td></tr>
    <tr><td class="paramname">g2</td><td>Second reduced shear component</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding distortions, e1 and e2. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf4d0acc084bdcb8cb85892463661233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.interleaveImages </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_flux</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>suppress_warnings</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>catch_offset_errors</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the pixel values from two or more images and into a single larger image. </p>
<p>This routine converts a list of images taken at a series of (uniform) dither offsets into a single higher resolution image, where the value in each final pixel is the observed pixel value from exactly one of the original images. It can be used to build a Nyquist-sampled image from a set of images that were observed with pixels larger than the Nyquist scale.</p>
<p>In the original observed images, the integration of the surface brightness over the pixels is equivalent to convolution by the pixel profile and then sampling at the centers of the pixels. This procedure simulates an observation sampled at a higher resolution than the original images, while retaining the original pixel convolution.</p>
<p>Such an image can be obtained in a fairly simple manner in simulations of surface brightness profiles by convolving them explicitly with the native pixel response and setting a lower sampling scale (or higher sampling rate) using the `pixel_scale' argument in drawImage() routine and setting the `method' parameter to `no_pixel'.</p>
<p>However, pixel level detector effects can be included only on images drawn at the native pixel scale, which happen to be undersampled in most cases. Nyquist-sampled images that also include the effects of detector non-idealities can be obtained by drawing multiple undersampled images (with the detector effects included) that are offset from each other by a fraction of a pixel.</p>
<p>This is similar to other procedures that build a higher resolution image from a set of low resolution images, such as MultiDrizzle and IMCOM. A disadvantage of this routine compared to ther others is that the images must be offset in equal steps in each direction. This is difficult to acheive with real observations but can be precisely acheived in a series of simulated images.</p>
<p>An advantage of this procedure is that the noise in the final image is not correlated as the pixel values are each taken from just a single input image. Thus, this routine preserves the noise properties of the pixels.</p>
<p>Here's an example script using this routine:</p>
<h2>Interleaving two Gaussian images along the x-axis </h2>
<pre class="fragment">&gt;&gt;&gt; n = 2
&gt;&gt;&gt; gal = galsim.Gaussian(sigma=2.8)
&gt;&gt;&gt; DX = numpy.arange(0.0,1.0,1./n)
&gt;&gt;&gt; DX -= DX.mean()
&gt;&gt;&gt; im_list, offsets = [], []
&gt;&gt;&gt; for dx in DX:
    ... offset = galsim.PositionD(dx,0.0)
    ... offsets.append(offset)
    ... im = galsim.Image(16,16)
    ... gal.drawImage(image=im,offset=offset,scale=1.0)
    ... im.applyNonlinearity(lambda x: x - 0.01*x**2) # detector effects
    ... im_list.append(im)
&gt;&gt;&gt; img = galsim.utilities.interleaveImages(im_list=im_list,N=(n,1),offsets=offsets)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im_list</td><td>A list containing the galsim.Image instances to be interleaved. </td></tr>
    <tr><td class="paramname">N</td><td>Number of images to interleave in either directions. It can be of type `int' if equal number of images are interleaved in both directions or a list or tuple of two integers, containing the number of images in x and y directions respectively. </td></tr>
    <tr><td class="paramname">offsets</td><td>A list containing the offsets as galsim.PositionD instances corresponding to every image in `im_list'. The offsets must be spaced equally and must span an entire pixel area. The offset values must be symmetric around zero, hence taking positive and negative values, with upper and lower limits of +0.5 and -0.5 (limit values excluded). </td></tr>
    <tr><td class="paramname">add_flux</td><td>Should the routine add the fluxes of all the images (True) or average them (False)? [default: True] </td></tr>
    <tr><td class="paramname">suppress_warnings</td><td>Suppresses the warnings about the pixel scale of the output, if True. [default: False] </td></tr>
    <tr><td class="paramname">catch_offset_errors</td><td>Checks for the consistency of <code>offsets</code> with <code>N</code> and raises Errors if inconsistencies found (True). Recommended, but could slow down the routine a little. [default: True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interleaved image </dd></dl>

</div>
</div>
<a class="anchor" id="ae3d1586e7c70ecfd9582b71f6f5147ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.kxky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array_shape</em> = <code>(256,&#160;256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tuple <code>(kx, ky)</code> corresponding to the DFT of a unit integer-sampled array of input shape. </p>
<p>Uses the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> conventions for Fourier space, so <code>k</code> varies in approximate range (-pi, pi]. Uses the most common DFT element ordering conventions (and those of FFTW), so that <code>(0, 0)</code> array element corresponds to <code>(kx, ky) = (0, 0)</code>.</p>
<p>See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here, but misses a factor of pi.</p>
<p>Adopts NumPy array index ordering so that the trailing axis corresponds to <code>kx</code>, rather than the leading axis as would be expected in IDL/Fortran. See docstring for numpy.meshgrid which also uses this convention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_shape</td><td>The NumPy array shape desired for <code>kx, ky</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af424a90c9e1c9f64eaaf4f52bcb1aceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.parse_pos_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integer</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the args and kwargs of a function call to be some kind of position. </p>
<p>We allow four options: </p>
<pre class="fragment">f(x,y)
f(galsim.PositionD(x,y)) or f(galsim.PositionI(x,y))
f( (x,y) )  (or any indexable thing)
f(name1=x, name2=y)
</pre><p>If the inputs must be integers, set <code>integer=True</code>. If there are other args/kwargs to parse after these, then their names should be be given as the parameter <code>others</code>, which are passed back in a tuple after the position. </p>

</div>
</div>
<a class="anchor" id="abbd8593ea30d16263c2f03e1147b5b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rand_arr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deviate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make a 2d array of random deviates (of any sort). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A list of length 2, indicating the desired 2d array dimensions </td></tr>
    <tr><td class="paramname">deviate</td><td>Any GalSim deviate (see random.py) such as <a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.). ">UniformDeviate</a>, <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution. ">GaussianDeviate</a>, etc. to be used to generate random numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NumPy array of the desired dimensions with random numbers generated using the supplied deviate. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e9d483f84e5d442b47384d26f5f65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.roll2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iroll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jroll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a 2D roll (circular shift) on a supplied 2D NumPy array, conveniently. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The NumPy array to be circular shifted. </td></tr>
    <tr><td class="paramname">(iroll,jroll)</td><td>The roll in the i and j dimensions, respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rolled image. </dd></dl>

</div>
</div>
<a class="anchor" id="af0e66b2539898963681cd1bf1fba0214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rotate_xy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates points in the xy-Cartesian plane counter-clockwise through an angle <code>theta</code> about the origin of the Cartesian coordinate system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>NumPy array of input <code>x</code> coordinates </td></tr>
    <tr><td class="paramname">y</td><td>NumPy array of input <code>y</code> coordinates </td></tr>
    <tr><td class="paramname">theta</td><td>Rotation angle (+ve counter clockwise) as an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated coordinates <code>(x_rot,y_rot)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a726162f079025bf5e5a622702d001ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input <code>x,f</code> values can be lists, NumPy arrays, or really anything that can be converted to a NumPy array. The new lists will be output as python lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code>x</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The <code>f</code> values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. [default: 1.e-4] </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of <code>x</code> be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists <code>(x_new, y_new)</code> with the thinned tabulation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
